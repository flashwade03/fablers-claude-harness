# Conversation-to-Skill Transformation Guide

대화에서 발견된 패턴을 스킬로 변환할 때, 원본 대화는 산발적이고 시행착오가 섞여 있다. 이것을 정제된 절차적 지식으로 변환하는 것이 핵심 과제다.

## Transformation Principles

### 1. 최종 경로만 추출한다

대화에는 시행착오, 수정, 되돌림이 포함된다. 스킬에는 **최종적으로 작동한 경로**만 담는다.

**대화 원문 (산발적)**:
```
User: 이 API에서 데이터 가져와줘
Claude: fetch로 가져옵니다... (실패)
Claude: CORS 문제네요, 프록시를 설정합니다... (실패)
Claude: 서버사이드에서 호출하는 방식으로 변경합니다 (성공)
```

**스킬 변환 (정제됨)**:
```
## External API Data Fetching
1. 서버사이드에서 API를 호출한다 (CORS 회피)
2. ...

## Constraints
- 클라이언트에서 직접 외부 API를 호출하지 말 것 — CORS 문제 발생
```

시행착오 과정 자체는 **Constraints**(금지 사항)로 변환한다. "X를 하지 말 것 — Y 문제 발생"이 시행착오에서 추출하는 핵심 형식이다.

### 2. 추상화 수준을 올린다

대화에서는 특정 파일명, 변수명, 프로젝트 구조가 등장한다. 스킬에서는 이것을 일반화한다.

| 대화 원문 | 스킬 변환 |
|-----------|----------|
| `src/components/Header.tsx`에서 상태를 관리 | 최상위 레이아웃 컴포넌트에서 상태를 관리 |
| `useEffect`에서 `fetchUsers()` 호출 | 마운트 시 데이터를 페칭 |
| `CLAUDE.md`에 링크 추가 | 프로젝트 설정 문서에 참조를 추가 |

**예외**: 특정 도구/라이브러리가 패턴의 핵심일 때는 구체적으로 유지한다.
- "ffmpeg -i input.mp4 -vf scale=1280:720 output.mp4" → 이건 추상화하면 안 된다
- 이 구분 기준: **다른 프로젝트에서도 그대로 쓸 수 있는가?** Yes면 구체적으로 유지.

### 3. 암묵적 판단을 명시적 기준으로 변환한다

대화에서 Claude가 암묵적으로 내린 판단이나 사용자가 직관적으로 결정한 것을 명시적 기준으로 바꾼다.

**대화 원문 (암묵적)**:
```
User: 이건 좀 복잡하니까 설계부터 하자
Claude: 네, 설계 문서를 작성하겠습니다
```

**스킬 변환 (명시적)**:
```
## Scope Check
다음 조건에 해당하면 설계 문서를 먼저 작성한다:
- 새로운 구조적 결정이 필요한 경우
- 3개 이상의 컴포넌트가 상호작용하는 경우
- ...
```

핵심 질문: **"이 판단을 다음에 다시 내려야 할 때, 무슨 기준으로 판단했는가?"** 그 기준을 스킬에 적는다.

### 4. 사용자 결정과 AI 결정을 구분한다

대화에서 나온 결정 중:
- **사용자가 명시적으로 선택한 것** → 스킬의 "사용자에게 물어볼 것" 목록
- **AI가 자율적으로 결정한 것** → 스킬의 워크플로우 스텝
- **대화 맥락에 의존하는 것** → 스킬에 포함하지 않음

## Transformation Process

### Phase 1: 원재료 수집

대화에서 다음을 추출한다:

1. **액션 시퀀스**: Claude가 실행한 도구/명령의 순서
2. **사용자 피드백 포인트**: 사용자가 수정/거부/승인한 지점
3. **도메인 팩트**: 대화 중 밝혀진 비자명한 사실
4. **실패-성공 쌍**: 실패한 접근 → 성공한 접근

### Phase 2: 구조화

수집한 원재료를 스킬 구조에 배치한다:

| 원재료 | 스킬 배치 위치 |
|--------|--------------|
| 최종 성공 경로의 액션 시퀀스 | SKILL.md의 Step N 워크플로우 |
| 실패한 접근 | Constraints ("하지 말 것") |
| 사용자 피드백 포인트 | "사용자에게 확인할 것" 체크포인트 |
| 도메인 팩트 | references/ 파일 또는 SKILL.md의 도메인 섹션 |
| 반복 사용된 도구 명령 | scripts/ 파일 |

### Phase 3: 검증 질문

변환 완료 후, 각 스킬 콘텐츠에 대해:

1. **"이 세션의 프로젝트를 모르는 사람이 읽어도 이해되는가?"** → No면 추상화 수준을 올릴 것
2. **"이 스텝을 빼면 워크플로우가 깨지는가?"** → No면 삭제
3. **"이 내용은 다른 프로젝트에서도 유효한가?"** → No면 해당 프로젝트 특화 내용을 일반화하거나 제거

## Common Transformation Pitfalls

### 세션 디테일을 그대로 복사

대화의 구체적 내용을 그대로 스킬에 넣으면 재사용성이 없어진다.

❌: "Header.tsx의 `useState`를 `useReducer`로 변경한다"
✅: "상태가 3개 이상 연관될 때 상태 관리를 단일 리듀서로 통합한다"

### 시행착오를 워크플로우에 포함

실패한 접근이 스텝으로 들어가면 혼란을 준다.

❌: "Step 1: fetch로 시도 → Step 2: 실패하면 프록시 설정 → Step 3: 그래도 실패하면 서버사이드"
✅: "Step 1: 서버사이드에서 호출" + Constraint: "클라이언트 직접 호출 금지"

### 판단 기준 없이 결론만 기록

"설계 문서를 먼저 작성한다"만 적으면, 언제 그래야 하는지 모른다.

❌: "복잡한 기능은 설계 문서를 작성한다"
✅: "다음 조건 중 2개 이상 해당 시 설계 문서를 작성한다: [기준 목록]"
